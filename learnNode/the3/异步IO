1.异步非阻塞
    非阻塞I/O返回的是当前调用的状态，需要通过轮询确认数据是否完整
    epoll:出现IO事件非阻塞调用，然后进入休眠，等待事件将其唤醒
    实际异步IO:线程池
    提交请求 处理结果

2.事件循环
    模型：生产者/消费者
    来源：
        浏览器端：用户交互，文件加载
        Node:网络请求,IO
    四要素：事件循环、观察者、请求对象、I/O线程池
    异步发起：从JS发起调用到内核执行完I/O的过渡过程中，存在一种中间产物--请求对象，请求对象封装当前传入的参数和方法
    该对象被推入线程池等待执行，当线程池有可用线程时，根据传入参数调用相应的底层函数
    执行回调：线程池IO操作调用完毕后，通过线程通信的方式，告知当前对象的操作已完成，归还线程至线程池，
    与此同时，如果线程池还有未执行的线程，会将请求对象对象加入观察者的队列中，当作事件处理


    定时器：
        定时器对象，超时形成事件 //回调函数保存在链表中，每轮循环执行链表中一个
        handle
    process.nextTick():下一次tick 回调函数保存在数组中，每轮循环全部执行

    为了保存每轮循环能较快的执行结束，防止CPU占用过多而阻塞后续I/O调用


3.事件驱动
    无需为每个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销
    Node可以处理具体业务，而且与背后的网络保持异步畅通



